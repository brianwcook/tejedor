# PyPI Proxy - Project Specifications

## Overview

The PyPI Proxy is a Go application that implements a proxy server for the Python Package Index (PyPI), providing intelligent routing between a public PyPI index and a private index. The application implements the [Simple Repository API](https://packaging.python.org/en/latest/specifications/simple-repository-api/) specification.

## Requirements

### Functional Requirements

1. **Dual Index Support**
   - Must communicate with public PyPI at `https://pypi.org/simple/`
   - Must communicate with a configurable private PyPI index
   - Both indexes must be configurable via configuration file

2. **Intelligent Routing Logic**
   - **Public Only**: When a package exists only in public PyPI, serve from public index
   - **Both Indexes**: When a package exists in both indexes, serve from private index (priority)
   - **Private Only**: When a package exists only in private index, serve from private index
   - **Not Found**: When a package doesn't exist in either index, return 404

3. **Simple Repository API Compliance**
   - Must implement the complete Simple Repository API specification
   - Must handle package index requests (`/simple/`)
   - Must handle package page requests (`/simple/{package}/`)
   - Must handle package file requests (`/packages/{file}`)
   - Must return appropriate HTTP status codes and content types

4. **Caching System**
   - Must implement LRU cache with configurable size (default: 20,000 entries)
   - Must implement TTL (default: 12 hours)
   - Must cache package existence information for both indexes
   - Must support cache disable option for testing

5. **Response Headers**
   - Must include `X-PyPI-Source` header in all responses
   - Header values: `public`, `private`, or `proxy`
   - Must be consistent across all response types

6. **Configuration Management**
   - Must support YAML configuration files
   - Must support environment variables
   - Must validate required configuration parameters
   - Must provide sensible defaults

### Non-Functional Requirements

1. **Performance**
   - Must handle concurrent requests efficiently
   - Must minimize latency through caching
   - Must support high throughput

2. **Reliability**
   - Must handle network failures gracefully
   - Must provide meaningful error messages
   - Must implement proper error handling

3. **Security**
   - Must not expose sensitive configuration in logs
   - Must validate input parameters
   - Must handle malformed requests safely

4. **Maintainability**
   - Must be well-documented
   - Must have comprehensive test coverage
   - Must follow Go best practices

## Technical Architecture

### Component Structure

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   HTTP Server   │    │   Proxy Logic   │    │   PyPI Client   │
│   (main.go)     │◄──►│   (proxy.go)    │◄──►│   (client.go)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Configuration │    │   LRU Cache     │    │   HTTP Client   │
│   (config.go)   │    │   (cache.go)    │    │   (net/http)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Data Flow

1. **Request Processing**
   ```
   HTTP Request → Router → Proxy Handler → Cache Check → PyPI Client → Response
   ```

2. **Caching Flow**
   ```
   Package Request → Cache Lookup → [Cache Hit] → Return Cached Data
                                ↓
                           [Cache Miss] → PyPI Check → Update Cache → Return Data
   ```

3. **Routing Decision**
   ```
   Package Name → Check Public Index → Check Private Index → Decision Logic → Serve Content
   ```

## API Specification

### Endpoints

#### 1. Index Page
- **URL**: `/` or `/simple/`
- **Method**: `GET`
- **Response**: HTML page with proxy information
- **Headers**: `X-PyPI-Source: proxy`

#### 2. Package Page
- **URL**: `/simple/{package}/`
- **Method**: `GET`
- **Response**: HTML page with package information
- **Headers**: `X-PyPI-Source: {public|private}`

#### 3. Package Files
- **URL**: `/packages/{file_path}`
- **Method**: `GET`
- **Response**: Binary file content
- **Headers**: `X-PyPI-Source: {public|private}`

### Response Headers

All responses must include:
- `X-PyPI-Source`: Indicates the source of the content
  - `public`: Content from public PyPI
  - `private`: Content from private PyPI
  - `proxy`: Content generated by the proxy

### Error Responses

- **400 Bad Request**: Invalid request format
- **404 Not Found**: Package not found in either index
- **500 Internal Server Error**: Proxy or upstream error

## Configuration Specification

### Configuration File Format (YAML)

```yaml
public_pypi_url: "https://pypi.org/simple/"
private_pypi_url: "https://your-private-pypi.com/simple/"
port: 8080
cache_enabled: true
cache_size: 20000
cache_ttl_hours: 12
```

### Environment Variables

| Variable | Description | Required |
|----------|-------------|----------|
| `PYPI_PROXY_PRIVATE_PYPI_URL` | Private PyPI URL | Yes |
| `PYPI_PROXY_PUBLIC_PYPI_URL` | Public PyPI URL | No |
| `PYPI_PROXY_PORT` | Server port | No |
| `PYPI_PROXY_CACHE_ENABLED` | Enable/disable cache | No |
| `PYPI_PROXY_CACHE_SIZE` | Cache size | No |
| `PYPI_PROXY_CACHE_TTL_HOURS` | Cache TTL | No |

### Default Values

- `public_pypi_url`: `https://pypi.org/simple/`
- `port`: `8080`
- `cache_enabled`: `true`
- `cache_size`: `20000`
- `cache_ttl_hours`: `12`

## Caching Specification

### Cache Implementation

- **Type**: LRU (Least Recently Used) cache
- **Storage**: In-memory with thread-safe access
- **Scope**: Package existence information per index
- **Expiration**: Time-based expiration (TTL)

### Cache Operations

1. **Get**: Retrieve cached package information
2. **Set**: Store package information with timestamp
3. **Clear**: Remove all cached entries
4. **Stats**: Get cache statistics

### Cache Key Format

- Public index: `{package_name}`
- Private index: `{package_name}`

### Cache Entry Structure

```go
type PackageInfo struct {
    Exists     bool
    LastUpdate time.Time
}
```

## Testing Strategy

### Unit Tests

1. **Configuration Tests**
   - Default configuration values
   - Environment variable loading
   - Configuration file loading
   - Validation errors

2. **Cache Tests**
   - Cache creation and configuration
   - Get/Set operations
   - TTL expiration
   - Cache statistics
   - Thread safety

3. **PyPI Client Tests**
   - HTTP request handling
   - Response parsing
   - Error handling
   - Package name normalization

4. **Proxy Logic Tests**
   - Request routing
   - Response header generation
   - Error handling
   - Package name extraction

### Integration Tests

1. **Real PyPI Integration**
   - Test with actual PyPI indexes
   - Verify routing logic with real packages
   - Test response headers
   - Test file proxying

2. **Cache Integration**
   - Test caching with real requests
   - Verify cache hit/miss behavior
   - Test cache expiration

3. **Error Scenarios**
   - Network failures
   - Invalid URLs
   - Malformed requests

### Test Examples

#### Package Examples

1. **pycups**
   - Exists only in public PyPI
   - Expected source: `public`
   - Expected behavior: Serve from public index

2. **pydantic**
   - Exists in both indexes
   - Expected source: `private`
   - Expected behavior: Serve from private index

3. **Non-existent Package**
   - Exists in neither index
   - Expected behavior: Return 404

## Implementation Details

### Package Name Normalization

PyPI uses normalized package names in URLs:
- Underscores (`_`) are converted to hyphens (`-`)
- Package names are converted to lowercase

Example: `test_package` → `test-package`

### File Path Handling

Package files are served from the `/packages/` path:
- File paths are preserved as-is
- Package names are extracted from filenames
- Source determination uses extracted package name

### Error Handling

1. **Network Errors**
   - Timeout handling
   - Connection failures
   - HTTP error responses

2. **Configuration Errors**
   - Missing required parameters
   - Invalid URLs
   - Invalid configuration values

3. **Request Errors**
   - Malformed URLs
   - Invalid package names
   - Missing parameters

## Performance Considerations

### Optimization Strategies

1. **Caching**
   - Cache package existence to reduce HTTP requests
   - Use LRU eviction for memory management
   - Implement TTL to ensure data freshness

2. **Concurrent Access**
   - Thread-safe cache operations
   - Concurrent HTTP requests
   - Connection pooling

3. **Memory Management**
   - Efficient data structures
   - Proper resource cleanup
   - Memory leak prevention

### Monitoring

1. **Metrics**
   - Request count and response times
   - Cache hit/miss ratios
   - Error rates

2. **Logging**
   - Request logs with source information
   - Error logs with context
   - Startup configuration summary

## Security Considerations

### Input Validation

1. **Package Names**
   - Validate package name format
   - Prevent path traversal attacks
   - Sanitize user input

2. **URLs**
   - Validate configuration URLs
   - Prevent SSRF attacks
   - Use HTTPS for sensitive operations

### Data Protection

1. **Configuration**
   - Don't log sensitive URLs
   - Use environment variables for secrets
   - Validate configuration at startup

2. **Headers**
   - Sanitize response headers
   - Don't forward sensitive headers
   - Validate header values

## Deployment Considerations

### Containerization

- Docker image with minimal footprint
- Multi-stage builds for optimization
- Health check endpoints
- Graceful shutdown handling

### Configuration Management

- Environment-based configuration
- Secret management integration
- Configuration validation
- Hot reload support (future)

### Monitoring and Observability

- Health check endpoints
- Metrics collection
- Structured logging
- Error tracking

## Future Enhancements

### Potential Features

1. **Authentication**
   - Basic authentication support
   - API key authentication
   - OAuth integration

2. **Advanced Caching**
   - Redis backend support
   - Distributed caching
   - Cache warming strategies

3. **Load Balancing**
   - Multiple private index support
   - Health checking
   - Failover mechanisms

4. **Metrics and Monitoring**
   - Prometheus metrics
   - Grafana dashboards
   - Alerting rules

5. **Rate Limiting**
   - Request rate limiting
   - IP-based restrictions
   - Quota management

### Performance Improvements

1. **HTTP/2 Support**
   - Multiplexing
   - Header compression
   - Server push

2. **Compression**
   - Response compression
   - File compression
   - Bandwidth optimization

3. **CDN Integration**
   - Static file caching
   - Geographic distribution
   - Edge computing

### 7. HTML/Version List Caching
- The proxy caches the full HTML content of `/simple/{package}/` responses for both public and private indexes.
- Cache structure:
  ```go
  type PackagePageInfo struct {
      HTML       []byte
      LastUpdate time.Time
  }
  ```
- Cache key: `{package_name}` (same as existence cache)
- Both existence and HTML content are cached independently.
- Cache stats are available via the health endpoint.

### 8. Health Endpoint
- **URL**: `/health`
- **Method**: `GET`
- **Response**: JSON with status and cache statistics
- **Example Output**:
  ```json
  {
    "status": "healthy",
    "cache": {
      "enabled": true,
      "public_packages": 123,
      "private_packages": 45,
      "public_pages": 67,
      "private_pages": 12
    }
  }
  ```

## License

This project is licensed under the GNU Affero General Public License v3.0 (AGPL-3.0).

Copyright (C) 2024 Brian Cook <bcook@redhat.com> 